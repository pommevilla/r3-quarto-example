{
  "hash": "e5bbadbe751fc0ffaac0ec86e8a87fe3",
  "result": {
    "markdown": "---\ntitle: \"A Pure Python Doc\"\nformat: html\n---\n\nThis is a pure Python qmd document. Since there are no R code chunks, it is executed via the Jupyter kernel. Because it's written in a `qmd` file, all of the Rmarkdown/knitr functionality you're used to can be used here. Here is some example code below.\n\n\n## Adding days per month from date range to a dataframe\n\nSuppose you have a dataset with a column of start dates and column of end dates. For example:\n\n::: {.cell}\n``` {.python .cell-code}\nimport pandas as pd\nimport calendar\n\ndate_df = pd.DataFrame({\n    \"START_TM\": ['2/15/2010', '2/15/2010', '3/16/2010'],\n    \"END_TM\": ['4/18/2010', '2/18/2010', '5/20/2010']\n})\ndate_df[\"START_TM\"] = date_df[\"START_TM\"].astype('datetime64')\ndate_df[\"END_TM\"] = date_df[\"END_TM\"].astype('datetime64')\ndate_df\n```\n\n::: {.cell-output-display}\n```{=tex}\n\\begin{tabular}{lll}\n\\toprule\n{} &   START\\_TM &     END\\_TM \\\\\n\\midrule\n0 & 2010-02-15 & 2010-04-18 \\\\\n1 & 2010-02-15 & 2010-02-18 \\\\\n2 & 2010-03-16 & 2010-05-20 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nOur goal is to count the number of days in each month this range of dates falls over.\n\nWe start by adding columns for each month:\n\n::: {.cell}\n``` {.python .cell-code}\nmonths = {calendar.month_name[i]:[0 for _ in range(date_df.shape[0])] for i in range(1, 13)}\nfor m in months:\n    date_df[m] = [0 for _ in range(date_df.shape[0])]\ndate_df\n```\n\n::: {.cell-output-display}\n```{=tex}\n\\begin{tabular}{lllrrrrrrrrrrrr}\n\\toprule\n{} &   START\\_TM &     END\\_TM &  January &  February &  March &  April &  May &  June &  July &  August &  September &  October &  November &  December \\\\\n\\midrule\n0 & 2010-02-15 & 2010-04-18 &        0 &         0 &      0 &      0 &    0 &     0 &     0 &       0 &          0 &        0 &         0 &         0 \\\\\n1 & 2010-02-15 & 2010-02-18 &        0 &         0 &      0 &      0 &    0 &     0 &     0 &       0 &          0 &        0 &         0 &         0 \\\\\n2 & 2010-03-16 & 2010-05-20 &        0 &         0 &      0 &      0 &    0 &     0 &     0 &       0 &          0 &        0 &         0 &         0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n### Helper functions\n\n::: {.cell}\n``` {.python .cell-code}\ndef insert_days_per_month(outer_row):\n    dpm = days_per_month(outer_row)\n    for index, inner_row in dpm.iterrows():\n        outer_row[inner_row['Month']] = inner_row['NumDays']\n    return(outer_row)\n\ndef days_per_month(row):\n    s = pd.Series(index = pd.date_range(row[0], row[1]))[1: ] \n    days_in_month = s.resample('MS').size().to_period('m').\\\n    rename_axis('Month').reset_index(name = 'NumDays')\n    days_in_month['Month'] = days_in_month['Month'].apply(\n        lambda x: calendar.month_name[x.month])\n    return(days_in_month)\n```\n:::\n\n\nWe can get the desired result with apply:\n\n::: {.cell}\n``` {.python .cell-code}\ndate_df = date_df.apply(lambda x: insert_days_per_month(x), axis = 1)\ndate_df\n```\n\n::: {.cell-output-stderr}\n```\nDeprecationWarning:\n\nThe default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n\n```\n:::\n\n::: {.cell-output-display}\n```{=tex}\n\\begin{tabular}{lllrrrrrrrrrrrr}\n\\toprule\n{} &   START\\_TM &     END\\_TM &  January &  February &  March &  April &  May &  June &  July &  August &  September &  October &  November &  December \\\\\n\\midrule\n0 & 2010-02-15 & 2010-04-18 &        0 &        13 &     31 &     18 &    0 &     0 &     0 &       0 &          0 &        0 &         0 &         0 \\\\\n1 & 2010-02-15 & 2010-02-18 &        0 &         3 &      0 &      0 &    0 &     0 &     0 &       0 &          0 &        0 &         0 &         0 \\\\\n2 & 2010-03-16 & 2010-05-20 &        0 &         0 &     15 &     30 &   20 &     0 &     0 &       0 &          0 &        0 &         0 &         0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n## Interactive Widgets\n\nQuarto has support for interactive documents. Supported formats include:\n\n-   JavaScript: Observable JS\n\n-   R: Shiny\n\n-   Python: Jupyter Widgets are all supported, such as IPyLeaflet and Plotly\n\nHere are some examples:\n\n## IPyLeaflet\n\n::: {.cell}\n``` {.python .cell-code}\nfrom ipyleaflet import Map, Marker\n\ngood_eats = {\n  \"Cham Soot Gol\": (33.772819, -117.9694484),\n  \"The Boiling Crab\": (33.6996179, -117.8905689),\n  \"Tan Hoang Huong\": (33.7446965, -117.9629173)\n}\n\ncham_soot_gol = Map(center=good_eats[\"Cham Soot Gol\"], scroll_wheel_zoom=True)\nfor place in good_eats:\n  cham_soot_gol.add_layer(Marker(location=good_eats[place], title=place))\ncham_soot_gol\n```\n\n::: {.cell-output-display}\n```\nMap(center=[33.772819, -117.9694484], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_titlâ€¦\n```\n:::\n:::\n\n\n## Plotly\n\n::: {.cell}\n``` {.python .cell-code}\nimport plotly.express as px\ndf = px.data.iris()\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", \n                 color=\"species\", \n                 marginal_y=\"violin\", marginal_x=\"box\", \n                 trendline=\"ols\", template=\"simple_white\")\nfig.show()\n```\n\n::: {.cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n\n::: {.cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n:::\n\n\n",
    "supporting": [
      "second_files\\figure-pdf"
    ],
    "filters": []
  }
}